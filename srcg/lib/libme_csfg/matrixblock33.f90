!***********************************************************************
!                                                                      *
      SUBROUTINE MATRIXBLOCK33(IC,IR,NCOEC,INCOR,NCTEC,INC2,NMCBP,     &
                 NCORE,ELSTO)
!
!   This subroutine calls onescalar and computes one electron          *
!   matrix elements when IC and IR are of type 3 and 3                 *
!                                                                      *
!***********************************************************************
!   Written by CHONG-YANG CHEN                               JUNE 2020 *
!   Last modification by C. Y. Chen                          Dec  2022 *
!***********************************************************************
!...Translated by Gediminas Gaigalas  May 2021
!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------
      USE vast_kind_param, ONLY: DOUBLE
      USE parameter_def,   ONLY: NNNP
      USE symmatrix_mod
      USE buffer_C,   ONLY: NVCOEF, LABEL, COEFF
      USE debug_C,    ONLY: IBUG1
      USE decide_C
      USE def_C
      USE orb_C
!-----------------------------------------------
!   I n t e r f a c e   B l o c k s
!-----------------------------------------------
      IMPLICIT NONE
      EXTERNAL BREID,CORD
!----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
      INTEGER :: IC,IR,NCOEC,INCOR,NCTEC,INC2,NMCBP,NCORE
      REAL(DOUBLE)        :: ELSTO
!-----------------------------------------------
!   L o c a l   P a r a m e t e r s
!-----------------------------------------------
!      REAL(DOUBLE), PARAMETER :: CUTOFF = 1.0D-20
!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
      LOGICAL :: FLAGLL,FLAGLLUU,FLAGNONE,FLAGUL,FLAGUU,LTPOSE
      REAL(DOUBLE) :: EMTTMP,ATWINV,ENONSYM,TCOEFF,VCOEFF
      REAL(DOUBLE), DIMENSION(NNNW) :: TSHELL
      INTEGER :: I,IA,IB,IV,ISWAP,IC0,IC1,IC2,IC3,IC4,ICPTI,ICPTJ
      INTEGER :: ICSAV,ICW,IERROR,IR0,IR1,IR2,IR3,IR4IRPTK,IRPTL,N
      INTEGER :: IRSAV,IRW,ITYPE1,ITYPE2,ITYPE3,J,KL,LABVTMP,M,MTYPE
      INTEGER :: NDIFF1,NDIFF2,NORBCOLL,NORBCOLU,NORBROWL,NORBROWU
      INTEGER :: IR4,IRPTK,K,L
      INTEGER :: ICORBIF(3,5), IRORBIF(3,5)
!-----------------------------------------------------------------------
      ! The first COLUMN generated by symmetry-ordered-CSF ICC
      ! The first ROW generated by symmetry-ordered-CSF IRR
      ! Smallest list version
      ! ICW = ICTOT + 1
      ! IRW = IRTOT + 1

      ATWINV = 1.D0/EMN
      IBUG1 = 0

!   Set all matrix elements to zero
      ICSAV = IC
      IRSAV = IR

      !EMTBLOCK = 0.0D0
      TSHELL = 0.D0
      FLAGLL = .FALSE.     ! 11p-11p -- 11p-11d 
      FLAGUU = .FALSE.     ! 11s 11p -- 11p-11p
      FLAGUL = .FALSE.     ! 11s 11p -- 11p 11d
      FLAGLLUU = .FALSE.   ! 11s 11p -- 11s 11p
      FLAGNONE = .TRUE.
! Transfer  <a b | c a>  to < c a | a b >, then treated with FLAGUL = .true.
      LTPOSE = .FALSE. 
!
! Type 3 - 3, Identify the same symmetry-ordered orbs.
!
      IF (NTYPE(3,IR) .EQ. NTYPE(3,IC)) THEN
        IF (NTYPE(5,IR) .NE. NTYPE(5,IC)) THEN
          FLAGLL = .TRUE.
        ELSE
          FLAGLLUU = .TRUE.
        ENDIF
      ELSEIF (NTYPE(3,IR) .EQ. NTYPE(5,IC)) THEN
        ! IR: 11p 11d -- IC: 11p- 11p
! Transfer  <a b | c a>  to < c a | a b > by using FLAGUL
        ! 11p 11d -- 11p- 11p is transposed to 11p- 11p -- 11p 11d
        FLAGUL = .TRUE.
        LTPOSE = .TRUE.
      ELSEIF (NTYPE(5,IR) .EQ. NTYPE(3,IC)) THEN
        ! IR: 11s 11p -- IC: 11p 11d
        FLAGUL = .TRUE.
        LTPOSE = .FALSE.
      ELSEIF (NTYPE(5,IR) .EQ. NTYPE(5,IC)) THEN
        FLAGUU = .TRUE.
      ENDIF
      IF (FLAGLL.OR.FLAGUU.OR.FLAGUL.OR.FLAGLLUU) FLAGNONE = .FALSE.

! Transfer  <a b | c a>  to < c a | a b > by using FLAGUL
      IF (LTPOSE) THEN
        IC = IRSAV
        IR = ICSAV
        ! Smallest list version:
        !ICW = IRTOT + 1
        !IRW = ICTOT + 1
      ENDIF

      IC0 = IC
      IR0 = IR

! Number of symmetry-ordered orbs for the IC- and IR-th symmetry-ordered-CSFs
      NORBCOLL = NTYPE(4,IC) - NTYPE(3,IC) + 1
      NORBCOLU = NTYPE(6,IC) - NTYPE(5,IC) + 1
      NORBROWL = NTYPE(4,IR) - NTYPE(3,IR) + 1 
      NORBROWU = NTYPE(6,IR) - NTYPE(5,IR) + 1
      
      NDIFF1 = 0 
      NDIFF2 = 0
!
! The largest list version:
!
! Find the CSFs-Pair with the same symmetry-ordered orbitals 
! For FLEXIBLE orbitals, it is more convenient to deal 
! with IC0 and IR0:
! FLAGLLUU : IRW (4p-4p+) -- ICW (4p- 4p+)
! FLAGLL   : IRW (4p-4p+) -- ICW (4p- 4d-)
! FLAGUU   : IRW (4p-4p+) -- ICW (4s  4p+)
! FLAGUL   : IRW (4p-4p+) -- ICW (4p+ 4d-)

! Possibly for semi-diagonal matrixelement of 
! those 3 - 3 pairs with one or two same symorbs, such as 
! <(CORE A) 11p- 11p+ | h1 | (CORE B) 11p- 11p+ >

! Smallest list version
! Now build the FICTIOUS CSFs as needed.

      ! Step 1: make IR / IC as the first CSF generated by ICC/IRR
      ! symmetry-ordered CSFs, these two FICTIOUS CSFs are used for one-body,
      ! two-body electronic interaction, and MTYPE 4 Breit calculations. 
      IF (NORBCOLL.GE.2 .OR. NORBCOLU.GE.2) THEN
        ! NTYPE(4,IC) ==> NTYPE(3,IC)
        CALL FICTIOUS_CSF(2, ICFICT+1, IC, NTYPE(3,IC), NTYPE(4,IC), 0, 0)
        ! NTYPE(6,IC) ==> NTYPE(5,IC)
        CALL FICTIOUS_CSF(2, ICFICT+2, ICFICT+1, NTYPE(5,IC), NTYPE(6,IC), 0, 0)
        ! Copy ICFICT+2 into ICFICT
        CALL FICTIOUS_CSF(2, ICFICT, ICFICT+2, 0, 0, 0, 0)
        ICORBIF(1,4) = ICFICT
      ELSE
        ! Only one TYPE 3 CSFs spanned by IC
        ICORBIF(1,4) = IC
      ENDIF
      ICORBIF(2,4) = NTYPE(3,IC)
      ICORBIF(3,4) = NTYPE(5,IC)

      ICORBIF(:,1) = ICORBIF(:,4)
      ICORBIF(:,2) = ICORBIF(:,4)
      ICORBIF(:,3) = ICORBIF(:,4)

      !IF (IC.EQ.2756.AND.IR.EQ.163) &
      !  write(*,*)"ICORBIF(1,4)=", ICORBIF(1,4)
      !IF (IC.EQ.2756.AND.IR.EQ.163) CALL PRINTFICTCSF(IC, IR,ICORBIF(1,4))

      IF (NORBROWL.GE.2 .OR. NORBROWU.GE.2) THEN
        ! NTYPE(4,IR) ==> NTYPE(3,IR)
        CALL FICTIOUS_CSF(2, IRFICT+1, IR, NTYPE(3,IR), NTYPE(4,IR), 0, 0)
        ! NTYPE(6,IR) ==> NTYPE(5,IR)
        CALL FICTIOUS_CSF(2, IRFICT+2, IRFICT+1, NTYPE(5,IR), NTYPE(6,IR), 0, 0)
        ! Copy IRFICT+2 into IRFICT
        CALL FICTIOUS_CSF(2, IRFICT, IRFICT+2, 0, 0, 0, 0)
        IRORBIF(1,4) = IRFICT
      ELSE
        ! Only one TYPE 3 CSFs spanned by IR
        IRORBIF(1,4) = IR
      ENDIF
      IRORBIF(2,4) = NTYPE(3,IR)
      IRORBIF(3,4) = NTYPE(5,IR)

      !IF (IC.EQ.2756.AND.IR.EQ.163) &
      !  write(*,*)"IRORBIF(1,4)=", IRORBIF(1,4)
      !IF (IC.EQ.2756.AND.IR.EQ.163) CALL PRINTFICTCSF(IC, IR,IRORBIF(1,4))
     
      IF (NTYPE(3,IR) .NE. NTYPE(3,IC) .AND.                         &
          NTYPE(3,IR) .NE. NTYPE(5,IC) .AND.                         &
          NTYPE(5,IR) .NE. NTYPE(3,IC) .AND.                         &
          NTYPE(5,IR) .NE. NTYPE(5,IC)) GOTO 101

!   Accumulate the contribution from the one-body operators:
!   kinetic energy, electron-nucleus interaction; update the
!   angular integral counter
      ENONSYM = 0.0D0
      TSHELL = 0.0d0 
      IA = 0
      IB = 0
      IC0 = ICORBIF(1,4)
      IR0 = IRORBIF(1,4)

      CALL ONESCALAR(IC0,IR0,IA,IB,TSHELL)
      TCOEFF = DBLE(TSHELL(1))
      IF (IA .NE. 0) THEN
!   Ensure that the indices are in `canonical' order
        IF (IA .GT. IB) THEN
          ISWAP = IB
          IB = IA
          IA = ISWAP
          IF (DABS(TCOEFF) .GT. CUTOFF) THEN
            !IF (IB .GT. NORBGEN .OR. (.NOT.FLAGLLUU)) then
            IF (IB .GT. NORBGEN) then
            ! For such CSF-pair, the one-body contribution should arise 
            ! from the core-orbitals. 
             WRITE(*,*)'IC,IR,IA,IB,TSHELL=',IC,IR,IA,IB,TSHELL(1)
             STOP 'Error, Modifications needed in matrixblock33 =1='
            ENDIF
          ENDIF
        ENDIF

        IF (DABS(TCOEFF) .GT. CUTOFF) THEN
          NCOEC = NCOEC + NTYPE(2,IC)
          IF (FLAGLLUU) THEN
           ! Different core, SAME two symmetry-ordered-orbs
           ! No needing to change IA, IB. The contribution is common to
           ! all semi-diagonal matrixelements. 
           CALL onebody_DC_MS_VP(IA,IB,ATWINV,TCOEFF,EMTTMP)

           ! Set the semi-diagonal matrixelements
           IF (NTYPE(2,IC).EQ.NTYPE(2,IR)) THEN
            DO I =1, NTYPE(2,IC)
             EMTBLOCK(I,I) = EMTTMP
            END DO
           ELSE ! The ICC - IRR block is not square 
            N = 0 ! Column index
            DO I = 1, NORBCOLL
             DO J = 1, NORBCOLU
              N = N + 1
              M = 0 ! Row index
              DO K = 1, NORBROWL
               DO L = 1, NORBROWU
                 M = M + 1
                 IF (K.EQ.I .AND. L.EQ.J) EMTBLOCK(M,N) = EMTTMP
               ENDDO
              ENDDO
             ENDDO
            ENDDO 
           ENDIF

          ELSE ! Same core, differing by one symmetry-ordered 
            WRITE(*,*)'IC,IR,IC0,IR0,IA,IB=',IC,IR,IC0,IR0,IA,IB
            STOP 'Modifications needed in matrixblock33 3 ...'
          ENDIF
        ENDIF
      ENDIF

101   CONTINUE 

!   Accumulate the contributions from the two-electron
!   Coulomb operator and the mass polarisation 
!   ENONSYM that does not include the symmetry-ordered orbital. 
      NVCOEF = 0
      ENONSYM = 0.D0

      ! IC0 = IC  OR ICORBIF(1,4)
      ! IR0 = IR  OR IRORBIF(1,4)
      CALL RKCO_GG (IC0, IR0, CORD, INCOR, 1)
      IF (NVCOEF .GT. 0) LTRANSFER = .TRUE.
      DO IV = 1, NVCOEF
        VCOEFF = COEFF(IV)
        IF (DABS (VCOEFF) .GT. CUTOFF) THEN
          NCTEC = NCTEC + NTYPE(2,IC) 

! Determine the position of the symmetry-ordered orbitals
          LABV=LABEL(1:6, IV)
          CALL ANALABV(IC, IR, IV)

          IF (NSYMCR .EQ. 0) THEN 
! If FLAGLLUU, maybe, there are contributions common to all
! semi-diagonal matrixelements of the IRR -ICC block.
           IF (.NOT.FLAGLLUU) THEN
            WRITE(*,'(a3, i7, 2x, i7, 2x, a5, 5i3)')                 &
                 'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
            STOP 'Warning!!! NSYMCR ERROR 33 ***0***'
           ENDIF
           CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
           ENONSYM = ENONSYM + EMTTMP

          ELSEIF (NSYMCR .EQ. 1) THEN 
           WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')              &
                'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
           STOP 'Warning!!! NSYMCR ERROR 33 ***1***'

! Matrixelement between Type 3 - 3
! Loop for symmetry-ordered-orbitals
          ELSEIF (NSYMCR .EQ. 2) THEN
           N = 0 ! COLUMN INDEX
           DO I = 1, NORBCOLL
            DO J = 1, NORBCOLU
             N = N + 1
             M = 0 ! ROW INDEX
             DO K = 1, NORBROWL
              DO L = 1, NORBROWU
               M = M + 1 
               !FULL MATRIX NEEDED
               !IF (K .GT. I) CYCLE
               !IF (K .EQ. I .AND. L.GT.J) CYCLE 
               IF (FLAGLL .AND. K.EQ.I .AND.                         &
                 LABEL(IPSYM(1),IV).EQ.ICORBIF(3,4)) THEN 
                 !LABEL(IPSYM(1),IV).EQ.NTYPE(6,IC0)) THEN 
                 LABV(IPSYM(1)) = NTYPE(5, IC) + J - 1
                 LABV(IPSYM(2)) = NTYPE(5, IR) + L - 1
                 CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
                 EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
               ELSEIF (FLAGUU .AND. L.EQ.J .AND.                     &
                       LABEL(IPSYM(1),IV).EQ.ICORBIF(2,4)) THEN
                       !LABEL(IPSYM(1),IV).EQ.NTYPE(4,IC0)) THEN
                 LABV(IPSYM(1)) = NTYPE(3, IC) + I - 1
                 LABV(IPSYM(2)) = NTYPE(3, IR) + K - 1
                 CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
                 EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
               ELSEIF (FLAGUL .AND. L.EQ.I) THEN
                 LABV(IPSYM(1)) = NTYPE(5, IC) + J - 1
                 LABV(IPSYM(2)) = NTYPE(3, IR) + K - 1
                 CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
                 EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
               ELSEIF (FLAGLLUU) THEN
                 !IF (K.EQ.I.AND.LABEL(IPSYM(1),IV).EQ.NTYPE(6, IC0)) THEN
                 IF (K.EQ.I.AND.LABEL(IPSYM(1),IV).EQ.ICORBIF(3,4)) THEN
                   LABV(IPSYM(1)) = NTYPE(5, IC) + J - 1
                   LABV(IPSYM(2)) = NTYPE(5, IR) + L - 1
                   CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
                   EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                 ENDIF
                 !IF (L.EQ.J.AND.LABEL(IPSYM(1),IV).EQ.NTYPE(4, IC0)) THEN
                 IF (L.EQ.J.AND.LABEL(IPSYM(1),IV).EQ.ICORBIF(2,4)) THEN
                   LABV(IPSYM(1)) = NTYPE(3, IC) + I - 1
                   LABV(IPSYM(2)) = NTYPE(3, IR) + K - 1
                   CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
                   EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP    
                 ENDIF
               ENDIF 
              
              ENDDO
             ENDDO
            ENDDO
           ENDDO

          ELSEIF (NSYMCR .EQ. 3) THEN
           WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')              &
                'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
           STOP 'Warning!!! NSYMCR ERROR 33 ***3***'

          ELSEIF (NSYMCR .EQ. 4) THEN 
           N=0 
           DO I = 1, NORBCOLL
            DO J = 1, NORBCOLU
             N = N + 1
             M = 0
             DO K = 1, NORBROWL
              DO L = 1, NORBROWU
               M = M + 1
               ! FULL MATRIX NEEDED
               !IF (K .GT. I) CYCLE 
               !IF (K .EQ. I .AND. L.GT.J) CYCLE  
               LABV(1) = NTYPE(3, IC) + I - 1
               LABV(2) = NTYPE(5, IC) + J - 1
               LABV(3) = NTYPE(3, IR) + K - 1
               LABV(4) = NTYPE(5, IR) + L - 1
               IF (LABEL(3,IV).GT.LABEL(4,IV)) THEN
                  LABVTMP = LABV(3)
                  LABV(3) = LABV(4)
                  LABV(4) = LABVTMP
               ENDIF
               CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
               EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
              ENDDO
             ENDDO
            ENDDO
           ENDDO

          ENDIF 
        ENDIF
      ENDDO
! Add the common parts for the semi-diagonal matrixelement 
      IF (DABS(ENONSYM) .GT. CUTOFF) THEN
       IF (.NOT.FLAGLLUU) THEN
        WRITE(*,*)'Unexpected .NOT.FLAGLLUU in B33.f, IC,IR=',IC,IR
        STOP 'Unexpected .NOT.FLAGLLUU in B33.f ...' 
       ENDIF
       IF (NTYPE(2,IC).EQ.NTYPE(2,IR)) THEN
        DO I = 1, NTYPE(2, IC)
           EMTBLOCK(I,I) = EMTBLOCK(I,I) + ENONSYM
        ENDDO
       ELSE ! Find the semi-diagonal matrixelement
        N = 0 ! Column index
        DO I = 1, NORBCOLL
         DO J = 1, NORBCOLU
          N = N + 1
          M = 0 ! Row index
          DO K = 1, NORBROWL
           DO L = 1, NORBROWU
             M = M + 1
             IF (K.EQ.I .AND. L.EQ.J)                                &
               EMTBLOCK(M,N) = EMTBLOCK(M,N) + ENONSYM
           ENDDO
          ENDDO
         ENDDO
        ENDDO 
       ENDIF
      ENDIF

      IBUG1 = 0
!
!   Accumulate the contribution from the two-electron
!   transverse interaction operator
      IF (LTRANS .AND. (INC2.EQ.1)) THEN 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                   <       IR  | h_br |    IC     >
! FLAGLLUU:========================================== 
! KTYPE 1:          < 11s 11p-          | 11s 11p- >
!  K  = I, L  = J:  < IR                |   IC     > 
! KTYPE 2:          < 11s 10p-          | 11s 11p- >
!  K  = I, L != J:  < IR - 1            |   IC     > 
! KTYPE 3:          < 10s 11p-          | 11s 11p- >
!  K != I, L  = J:  < IR - NORBROWU     |   IC     > 
! KTYPE 4:          < 10s 10p-          | 11s 11p- >
!  K != I, L != J:  < IR - NORBROWU - 1 |   IC     >
! FLAGLLUU:========================================== 

! FLAGLL=============================================
! KTYPE 5:          < 11s 11p-          | 11s 11p  >
!  K  = I,       :  < IR                |   IC     >
! KTYPE 6:          < 10s 11p-          | 11s 11p  >
!  K != I,       :  < IR - NORBROWU     |   IC     >
! FLAGLL=============================================

! FLAGUL=============================================
! KTYPE 7:          < 11s 11p-          | 11p-11p  >
!  L  = I,       :  < IR                |   IC     >
! KTYPE 8:          < 11s 10p-          | 11p-11p  >
!  L != I,       :  < IR - 1            |   IC     >
! FLAGLL=============================================

! FLAGUU=============================================
! KTYPE 9:          < 11s 11p           | 11p-11p  >
!  L  = J,       :  < IR                |   IC     >
! KTYPE10:          < 11s 10p           | 11p-11p  >
!  L != I,       :  < IR - 1            |   IC     >
! FLAGLL=============================================

! Without same symmetry-ordered-orbital======================
! KTYPE11:          < 11p-11p           | 11d-11d  >
!                   < IR                |   IC     >
! Without same symmetry-ordered-orbital======================

! MTYPE 1: KTYPE 4          < IR - NORBROWU - 1 |   IC  >
! MTYPE 2: KTYPE 2, 8, 10              < IR - 1 |   IC  >
! MTYPE 3: KTYPE 3, 6       < IR - NORBROWU     |   IC  > 
! MTYPE 4: KTYPE 1, 5, 7, 9, 11,       < IR | IC >
       ITYPE1 = 0
       ITYPE2 = 0
       ITYPE3 = 0
!
! ICW,IRW, IC1 - IC4, IR1 - IR4 are meaningless for the SMALLEST
! version. The corresponding FICTIOUS CSFs are constructed here.
!
      ! FLAGLLUU : IRW (4p-4p+) -- ICW (4p- 4p+)
      ! FLAGLL   : IRW (4p-4p+) -- ICW (4p- 4d-)
      ! FLAGUU   : IRW (4p-4p+) -- ICW (4s  4p+)
      ! FLAGUL   : IRW (4p-4p+) -- ICW (4p+ 4d-)

       IF (FLAGLLUU .OR. FLAGUU .OR. FLAGUL) THEN
         ! L.NE.J with K.EQ.I if FLAGLLUU, Used in MTYPE 2
         ! L.NE.J if FLAGUU, Used in MTYPE 2
         ! L.NE.I if FLAGUL, Used in MTYPE 2
         IF ((FLAGLLUU.OR.FLAGUU) .AND. (NORBROWU.GE.2.OR.NORBCOLU.GE.2) .OR. & 
            (FLAGUL .AND. (NORBROWU.GE.2 .OR. NORBCOLL.GE.2))) THEN
           ITYPE2 = 1
           ! FLAGLLUU : IR0 (4p-4p+) -- IC0 (4p- 4p+)
           ! FLAGUU   : IR0 (4p-4p+) -- IC0 (4s  4p+)
           ! FLAGUL   : IR0 (4p-4p+) -- IC0 (4p+ 4d-)
           ! >>>>>>>>
           ! FLAGLLUU : IR2 (4p-5p+) -- IC2 (4p- 4p+)
           ! FLAGUU   : IR2 (4p-5p+) -- IC2 (4s  4p+)
           ! FLAGUL   : IR2 (4p-5p+) -- IC2 (4p+ 4d-)

           !  Build the above needed FICTIOUS CSF from IRFICT   
           IR1 = IRORBIF(2,4)
           IR2 = IRORBIF(3,4)
           ! IR2 ==> IR2+1
           CALL FICTIOUS_CSF(2, IRFICT+1, IRORBIF(1,4), IR2+1, IR2, 0, 0)
           IRORBIF(1,2) = IRFICT+1
           IRORBIF(2,2) = IR1
           IRORBIF(3,2) = IR2+1
      !IF (IC.EQ.2756.AND.IR.EQ.163) &
      !  write(*,*)"IRORBIF(1,2)=", IRORBIF(1,2)
      !IF (IC.EQ.2756.AND.IR.EQ.163) CALL PRINTFICTCSF(IC, IR,IRORBIF(1,2))
         ENDIF
       ENDIF

       IF (FLAGLLUU .OR. FLAGLL) THEN
         ! K.NE.I, and L.EQ.J if FLAGLLUU, Used in MTYPE 3
         IF (NORBROWL.GE.2 .OR. NORBCOLL.GE.2) THEN
           ITYPE3 = 1
           ! FLAGLLUU : IR0 (4p-4p+) -- IC0 (4p- 4p+)
           ! FLAGLL   : IR0 (4p-4p+) -- IC0 (4p- 4d-)
           !>>>>
           ! FLAGLLUU : IR3 (5p-4p+) -- IC3 (4p- 4p+)
           ! FLAGLL   : IR3 (5p-4p+) -- IC3 (4p- 4d-)

           !  Build the above needed FICTIOUS CSF from IRFICT   
           IR1 = IRORBIF(2,4)
           IR2 = IRORBIF(3,4)
           ! IR1 ==> IR1+1
           CALL FICTIOUS_CSF(2, IRFICT+2, IRORBIF(1,4), IR1+1, IR1, 0, 0)
           IRORBIF(1,3) = IRFICT+2
           IRORBIF(2,3) = IR1+1
           IRORBIF(3,3) = IR2
         ENDIF
       ENDIF

       IF (FLAGLLUU) THEN
         ! K.NE.I AND L.NE.J, Used in MTYPE 1
         IF ((NORBROWL.GE.2 .AND. NORBROWU.GE.2) .OR.          &
             (NORBCOLL.GE.2 .AND. NORBCOLU.GE.2)) THEN
           ITYPE1 = 1
           ! FLAGLLUU : IR0 (4p-4p+) -- IC0 (4p- 4p+)
           ! >>>>>>>
           ! FLAGLLUU : IR1 (5p-5p+) -- IC1 (4p- 4p+)

           !Build the needed FICTIOUS CSF by using IRFICT+1:
           !IRFICT+1: IR2 (4p-5p+) -- IC2 (4p- 4p+)
           IR1 = IRORBIF(2,2)
           IR2 = IRORBIF(3,2)
           ! IR1 ==> IR1+1
           CALL FICTIOUS_CSF(2, IRFICT+3, IRFICT+1, IR1+1, IR1, 0, 0)
           IRORBIF(1,1) = IRFICT+3
           IRORBIF(2,1) = IR1+1
           IRORBIF(3,1) = IR2
         ENDIF
       ENDIF

       ! K.EQ.I AND L.EQ.J, Used in MTYPE 4
       ! Built as IRFICT and ICFICT, stored within IRORBIF(:,4) and
       ! ICORBIF(:,4)

! Smallest list version, these CHECKs should be modified. Left for
! future sometime.      
!       !Check
!       IERROR = 0
!       IF (ITYPE1.EQ.1) THEN
!        IF (.NOT.FLAGLLUU) IERROR = 1
!        IF (NTYPE(4,IR1).EQ.NTYPE(4,IC1)) IERROR = 2
!        IF (NTYPE(6,IR1).EQ.NTYPE(6,IC1)) IERROR = 3
!       ENDIF 
!       IF (ITYPE2.EQ.1) THEN
!        IF (FLAGLLUU .AND. NTYPE(4,IR2).NE.NTYPE(4,IC2)) IERROR = 4
!        IF (FLAGLLUU .AND. NTYPE(6,IR2).EQ.NTYPE(6,IC2)) IERROR = 5
!        IF (FLAGUU   .AND. NTYPE(6,IR2).EQ.NTYPE(6,IC2)) IERROR = 6
!        IF (FLAGUL   .AND. NTYPE(6,IR2).EQ.NTYPE(4,IC2)) IERROR = 7
!       ENDIF
!       IF (ITYPE3.EQ.1) THEN
!        IF (FLAGLLUU .AND. NTYPE(4,IR3).EQ.NTYPE(4,IC3)) IERROR = 8
!        IF (FLAGLLUU .AND. NTYPE(6,IR3).NE.NTYPE(6,IC3)) IERROR = 9
!        IF (FLAGLL   .AND. NTYPE(4,IR3).EQ.NTYPE(4,IC3)) IERROR = 10
!       ENDIF
!       IF (FLAGLLUU .AND. NTYPE(4,IR4).NE.NTYPE(4,IC4)) IERROR = 11
!       IF (FLAGLLUU .AND. NTYPE(6,IR4).NE.NTYPE(6,IC4)) IERROR = 12
!       IF (FLAGUU   .AND. NTYPE(6,IR4).NE.NTYPE(6,IC4)) IERROR = 13
!       IF (FLAGLL   .AND. NTYPE(4,IR4).NE.NTYPE(4,IC4)) IERROR = 14
!       IF (FLAGUL   .AND. NTYPE(6,IR4).NE.NTYPE(4,IC4)) IERROR = 15
!       IF (IERROR.NE.0) THEN
!        WRITE(*,*)'Unexpected match error in B33.f around Line 500 ...'
!        WRITE(*,*)'IC,IR,IERROR=',IC,IR,IERROR
!        WRITE(*,*)'IC1,IC2,IC3,IC4=', IC1,IC2,IC3,IC4
!        WRITE(*,*)'IR1,IR2,IR3,IR4=', IR1,IR2,IR3,IR4
!        WRITE(*,*)'NDIFF1,NDIFF2=',   NDIFF1,NDIFF2
!        WRITE(*,*)'FLAGs:',FLAGLLUU,FLAGLL,FLAGUU,FLAGUL
!        STOP 'Unexpected match error in B33.f around Line640...'
!       ENDIF

       ENONSYM = 0.D0
       DO MTYPE = 1, 4
        NVCOEF = 0
        COEFF = 0
        IF (MTYPE.EQ.1) THEN
         IF (ITYPE1.EQ.0) CYCLE
         ! FLAGLLUU
         ! KTYPE 4
         ! < K L | h_br | I J >: K != I, L != J
         CALL RKCO_GG (ICORBIF(1,MTYPE), IRORBIF(1,MTYPE), BREID, 1, 2)

        ELSEIF (MTYPE.EQ.2) THEN
         IF (ITYPE2.EQ.0) CYCLE
         ! KTYPE 2, 8, 10
         ! < K L | h_br | I J >: K = I, L != J
         !CALL RKCO_GG (IC2, IR2, BREID, 1, 2)
         CALL RKCO_GG (ICORBIF(1,MTYPE), IRORBIF(1,MTYPE), BREID, 1, 2)

        ELSEIF (MTYPE.EQ.3) THEN
         IF (ITYPE3.EQ.0) CYCLE 
         ! KTYPE 3, 6
         ! < K L | h_br | I J >: K != I,  L = J
         !CALL RKCO_GG (IC3, IR3, BREID, 1, 2)
         CALL RKCO_GG (ICORBIF(1,MTYPE), IRORBIF(1,MTYPE), BREID, 1, 2)

        ELSEIF (MTYPE.EQ.4) THEN
         ! KTYPE 1, 5, 7, 9, 11,       < IR | IC >, such as:
         ! < (Core) 10s10d | h_br | (Core) 10s10d >
         ! < K L | h_br | I J >: K = I, L = J

         ! .OR. Without any same sym-orb:
         ! < (Core) 10s10p | h_br | (Core) 10p- 10d->
         !  CALL RKCO_GG (IC, IR, BREID, 1, 2)
           CALL RKCO_GG (ICORBIF(1,MTYPE), IRORBIF(1,MTYPE),BREID,1,2)
        ENDIF
        IF (NVCOEF .GT. 0) LTRANSFER = .TRUE.
        DO 10 IV = 1, NVCOEF
          VCOEFF = COEFF(IV)
          IF (DABS (VCOEFF) .GT. CUTOFF) THEN
            NMCBP = NMCBP + NTYPE(2,IC)
! Determine the position of the symmetry-ordered orbitals
            LABV = LABEL(1:6,IV)
            CALL ANALABV(IC, IR, IV)

            IF (NSYMCR .EQ. 0) THEN
! Common for all diagonal matrixelement
             IF (MTYPE.NE.4 .OR. (.NOT.FLAGLLUU)) THEN
               WRITE(*,*)'IC,IR,MTYPE,IV,LABEL=',                    &
                          IC,IR,MTYPE,IV,LABEL(1:6,IV)
               STOP 'Unexpected MTYPE.NE.4 in matrixblock33.f ...'
             ENDIF
             CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
             ENONSYM = ENONSYM + EMTTMP

! Matrixelement between Type 1 - 2, 5, Loop for symmetry-ordered-orbitals
            ELSEIF (NSYMCR .EQ. 1) THEN
              WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')           &
                   'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
              STOP 'Warning!!! NSYMCR ERROR ***1***'

            ELSEIF (NSYMCR .EQ. 2) THEN
             IERROR = 0
             IF (MTYPE.EQ.1) IERROR = 1
             IF (MTYPE.EQ.2 .AND. (.NOT.FLAGLLUU)) IERROR = 2
             IF (MTYPE.EQ.3 .AND. (.NOT.FLAGLLUU)) IERROR = 3
             IF (MTYPE.EQ.4 .AND. FLAGNONE) IERROR = 4
             IF (IERROR.NE.0) THEN
              WRITE(*,*)                                             &
                  'IC=', IC, ' IR=', IR, ' LABV=', LABV(1:5),        &
                  ' MTYPE=', MTYPE,' IERROR=',IERROR
              STOP 'Unexpected IERROR.NE.0 in matrixblock33.f ...'
             ENDIF
! Determine the positions of the symmetry-ordered orbitals
             IRPTK = 0
             IRPTL = 0
             ICPTI = 0
             ICPTJ = 0
             !IF (MTYPE.EQ.1) THEN
             ! There is no NSYMCR .EQ. 2 for MTYPE.EQ.1
             IF (MTYPE.EQ.2) THEN
               !IF (LABEL(IPSym(1),IV).EQ.NTYPE(6,IR2)) THEN
               IF (LABEL(IPSym(1),IV).EQ.IRORBIF(3,2)) THEN
                 IRPTL = IPSym(1)
                 ICPTJ = IPSym(2)
               ELSE
                 IRPTL = IPSym(2)
                 ICPTJ = IPSym(1)
               ENDIF   
             ELSEIF (MTYPE.EQ.3) THEN
               !IF (LABEL(IPSym(1),IV).EQ.NTYPE(4,IR3)) THEN
               IF (LABEL(IPSym(1),IV).EQ.IRORBIF(2,3)) THEN
                 IRPTK = IPSym(1)
                 ICPTI = IPSym(2)
               ELSE
                 IRPTK = IPSym(2)
                 ICPTI = IPSym(1)
               ENDIF
             !ELSEIF (MTYPE.EQ.4) THEN
             ! Treated below
             ENDIF

! Loop over symmetry-ordered orbitals 
             N = 0  ! Column index
             DO I = 1, NORBCOLL
              DO J = 1, NORBCOLU
                N = N + 1
                M = 0
                DO K = 1, NORBROWL
                 DO L = 1, NORBROWU
                  M = M + 1  ! Row index
                  ! Full matrix needed
                  ! IF (K .GT. I) CYCLE ! IR INNER ALWAYS <= IC INNER ORB
                  ! IF (K .EQ. I .AND. L.GT.J) CYCLE 

                  IF (MTYPE.EQ.2 .AND. K.EQ.I .AND. L.NE.J) THEN
                    ! FLAGLLUU: < K L | h_br | L J >: K = I,  L != J
                    LABV(IRPTL) = NTYPE(5, IR) + L - 1
                    LABV(ICPTJ) = NTYPE(5, IC) + J - 1
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP

                  ELSEIF (MTYPE.EQ.3 .AND. K.NE.I .AND. L.EQ.J) THEN 
                    ! FLAGLLUU: < K L | h_br | L J >: K != I,  L =  J
                    LABV(IRPTK) = NTYPE(3, IR) + K - 1
                    LABV(ICPTI) = NTYPE(3, IC) + I - 1
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP

                  ELSEIF (MTYPE.EQ.4) THEN  
                    ! < K L | h_br | I J >
                   IF (FLAGLL .AND. K.EQ.I) THEN
                    IF (LABEL(IPSym(1),IV).EQ.IRORBIF(3,4)) THEN
                      LABV(IPSym(1)) = NTYPE(5, IR) + L - 1
                      LABV(IPSym(2)) = NTYPE(5, IC) + J - 1
                    ELSE
                      LABV(IPSym(2)) = NTYPE(5, IR) + L - 1
                      LABV(IPSym(1)) = NTYPE(5, IC) + J - 1
                    ENDIF
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP

                   ELSEIF (FLAGUL .AND. L.EQ.I) THEN
                    IF (LABEL(IPSym(1),IV).EQ.IRORBIF(2,4)) THEN
                      LABV(IPSym(1)) = NTYPE(3, IR) + K - 1
                      LABV(IPSym(2)) = NTYPE(5, IC) + J - 1
                    ELSE
                      LABV(IPSym(2)) = NTYPE(3, IR) + K - 1
                      LABV(IPSym(1)) = NTYPE(5, IC) + J - 1
                    ENDIF 
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                      
                   ELSEIF (FLAGUU .AND. L.EQ.J) THEN
                    IF (LABEL(IPSym(1),IV).EQ.IRORBIF(2,4)) THEN
                      LABV(IPSym(1)) = NTYPE(3, IR) + K - 1
                      LABV(IPSym(2)) = NTYPE(3, IC) + I - 1
                    ELSE
                      LABV(IPSym(2)) = NTYPE(3, IR) + K - 1
                      LABV(IPSym(1)) = NTYPE(3, IC) + I - 1
                    ENDIF
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP 
                      
                   ELSEIF (FLAGLLUU .AND. K.EQ.I .AND. L.EQ.J) THEN
                    IF (LABEL(IPSym(1),IV).EQ.IRORBIF(2,4)) THEN
                     LABV(IPSym(1)) = NTYPE(3, IR) + K - 1
                     LABV(IPSym(2)) = NTYPE(3, IC) + I - 1
                    ELSEIF (LABEL(IPSym(1),IV).EQ.IRORBIF(3,4)) THEN
                     LABV(IPSym(1)) = NTYPE(5, IR) + L - 1
                     LABV(IPSym(2)) = NTYPE(5, IC) + J - 1
                    ENDIF
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                        
                   ENDIF
                  ENDIF 
                  
                 ENDDO
                ENDDO
              ENDDO
             ENDDO

            ELSEIF (NSYMCR .EQ. 3) THEN
             WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')            &
                  'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
             STOP 'Warning!!! NSYMCR ERROR ***3***'

            ELSEIF (NSYMCR .EQ. 4) THEN
! Determine the positions of the symmetry-ordered orbitals 
             IF (MTYPE.EQ.1) THEN
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(2,1)) IRPTK = I
                 IF (LABEL(I,IV).EQ.IRORBIF(3,1)) IRPTL = I
                 IF (LABEL(I,IV).EQ.ICORBIF(2,1)) ICPTI = I
                 IF (LABEL(I,IV).EQ.ICORBIF(3,1)) ICPTJ = I
               ENDDO
             ENDIF
 
             IF (MTYPE.EQ.2) THEN
              IF (FLAGUU.OR.FLAGUL) THEN
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(2,2)) IRPTK = I
                 IF (LABEL(I,IV).EQ.IRORBIF(3,2)) IRPTL = I
                 IF (LABEL(I,IV).EQ.ICORBIF(2,2)) ICPTI = I
                 IF (LABEL(I,IV).EQ.ICORBIF(3,2)) ICPTJ = I
               ENDDO            
              ENDIF

              IF (FLAGLLUU) THEN
               IRPTK = 0
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(3,2)) IRPTL = I
                 IF (LABEL(I,IV).EQ.ICORBIF(3,2)) ICPTJ = I
                 IF (LABEL(I,IV).EQ.IRORBIF(2,2)) THEN
                   IF (IRPTK.EQ.0) THEN
                     IRPTK = I
                   ELSE
                     ICPTI = I
                   ENDIF 
                 ENDIF
               ENDDO 
              ENDIF
             ENDIF

             IF (MTYPE.EQ.3) THEN
              IF (FLAGLL) THEN
               DO I = 1, 4 
                 IF (LABEL(I,IV).EQ.IRORBIF(2,3)) IRPTK = I
                 IF (LABEL(I,IV).EQ.IRORBIF(3,3)) IRPTL = I
                 IF (LABEL(I,IV).EQ.ICORBIF(2,3)) ICPTI = I
                 IF (LABEL(I,IV).EQ.ICORBIF(3,3)) ICPTJ = I
               ENDDO
              ENDIF
              IF (FLAGLLUU) THEN
               IRPTL = 0
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(2,3)) IRPTK = I
                 IF (LABEL(I,IV).EQ.ICORBIF(2,3)) ICPTI = I
                 IF (LABEL(I,IV).EQ.IRORBIF(3,3)) THEN
                   IF (IRPTL.EQ.0) THEN
                     IRPTL = I
                   ELSE
                     ICPTJ = I
                   ENDIF
                 ENDIF
               ENDDO
              ENDIF
             ENDIF

             IF (MTYPE.EQ.4) THEN
              IF (FLAGNONE) THEN
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(2,4)) IRPTK = I
                 IF (LABEL(I,IV).EQ.IRORBIF(3,4)) IRPTL = I
                 IF (LABEL(I,IV).EQ.ICORBIF(2,4)) ICPTI = I
                 IF (LABEL(I,IV).EQ.ICORBIF(3,4)) ICPTJ = I
               ENDDO

              ELSEIF (FLAGLL) THEN
               IRPTK = 0
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(3,4)) IRPTL = I
                 IF (LABEL(I,IV).EQ.ICORBIF(3,4)) ICPTJ = I
                 IF (LABEL(I,IV).EQ.IRORBIF(2,4)) THEN
                   IF (IRPTK.EQ.0) THEN
                     IRPTK = I
                   ELSE
                     ICPTI = I
                   ENDIF
                 ENDIF
               ENDDO

              ELSEIF (FLAGUU) THEN
               IRPTL = 0
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(2,4)) IRPTK = I
                 IF (LABEL(I,IV).EQ.ICORBIF(2,4)) ICPTI = I
                 IF (LABEL(I,IV).EQ.IRORBIF(3,4)) THEN
                   IF (IRPTL.EQ.0) THEN
                     IRPTL = I
                   ELSE
                     ICPTJ = I
                   ENDIF
                 ENDIF
               ENDDO

              ELSEIF (FLAGUL) THEN
               IRPTL = 0
               DO I = 1, 4
                 IF (LABEL(I,IV).EQ.IRORBIF(2,4)) IRPTK = I
                 IF (LABEL(I,IV).EQ.ICORBIF(3,4)) ICPTJ = I
                 IF (LABEL(I,IV).EQ.IRORBIF(3,4)) THEN
                   IF (IRPTL.EQ.0) THEN
                     IRPTL = I
                   ELSE
                     ICPTI = I
                   ENDIF
                 ENDIF
               ENDDO

              ELSEIF (FLAGLLUU) THEN
               IRPTK = 0
               IRPTL = 0
               DO I = 1, 4
                IF (LABEL(I,IV).EQ.IRORBIF(2,4)) THEN
                 IF (IRPTK.EQ.0) THEN
                  IRPTK = I
                 ELSE
                  ICPTI = I
                 ENDIF
                ENDIF
                IF (LABEL(I,IV).EQ.IRORBIF(3,4)) THEN
                 IF (IRPTL.EQ.0) THEN
                   IRPTL = I
                 ELSE
                   ICPTJ = I
                 ENDIF
                ENDIF  
               ENDDO
              ENDIF
             ENDIF
! Check
             IF(IRPTK*IRPTL*ICPTI*ICPTJ.EQ.0) THEN
               WRITE(*,*)                                            &
                  'IC=',IC,' IR=',IR,' IV=',IV,' LABV=',LABV(1:5),   &
                  ' MTYPE=', MTYPE,                                  &
                  'IRPTK,IRPTL,ICPTI,ICPTJ=',IRPTK,IRPTL,ICPTI,ICPTJ
               STOP 'Unexpected IRPTK*IRPTL*ICPTI*ICPTJ.EQ.0 in B33.f .'
             ENDIF

! Loop over the symmetry-ordered orbitals
             N = 0  ! Column index
             DO I = 1, NORBCOLL
              DO J = 1, NORBCOLU
                N = N + 1
                M = 0
                DO K = 1, NORBROWL
                 DO L = 1, NORBROWU
                  M = M + 1  ! Row index
                  ! Full matrix needed
                  ! IF (K .GT. I) CYCLE ! IR INNER ALWAYS <= IC INNER ORB
                  ! IF (K .EQ. I .AND. L.GT.J) CYCLE

                  IF (MTYPE.EQ.1) THEN 
                    ! < K L | h_br | I J >: K != I, L != J
                    IF (K.EQ.I .OR. L.EQ.J) CYCLE
                  ELSEIF (MTYPE.EQ.2) THEN
                    ! < K L | h_br | I J >: K = I, L != J
                    IF (FLAGUU.AND.L.EQ.J) CYCLE
                    IF (FLAGUL.AND.L.EQ.I) CYCLE
                    IF (FLAGLLUU.AND.(K.NE.I .OR. L.EQ.J)) CYCLE
                  ELSEIF (MTYPE.EQ.3) THEN
                    ! < K L | h_br | I J >: K != I 
                    IF (FLAGLL.AND.K.EQ.I) CYCLE
                    ! < K L | h_br | I J >: K != I and L == J 
                    IF (FLAGLLUU.AND.(K.EQ.I .OR. L.NE.J)) CYCLE
                  ELSEIF (MTYPE.EQ.4) THEN
                    ! < K L | h_br | I J >: K = I, and L = J
                    IF (FLAGLL.AND.K.NE.I) CYCLE
                    IF (FLAGUU.AND.L.NE.J) CYCLE
                    IF (FLAGUL.AND.L.NE.I) CYCLE
                    IF (FLAGLLUU.AND.(K.NE.I.OR.L.NE.J)) CYCLE
                  ENDIF
                  LABV(IRPTK) = NTYPE(3,IR) + K - 1
                  LABV(IRPTL) = NTYPE(5,IR) + L - 1
                  LABV(ICPTI) = NTYPE(3,IC) + I - 1
                  LABV(ICPTJ) = NTYPE(5,IC) + J - 1
                  CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                  EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                 ENDDO
                ENDDO
              ENDDO
             ENDDO
            ENDIF
          ENDIF
   10   CONTINUE
       ENDDO

! Add the common part of the semi-diagonal matrixelements
       IF (ABS(ENONSYM).GT.CUTOFF) THEN
        IF (.NOT.FLAGLLUU) THEN
          WRITE(*,*)'IC,IR,ENONSYM=',IC,IR,ENONSYM
          STOP 'Unexpected .NOT.FLAGLLUU in B33.f ...' 
        ENDIF
        IF (NTYPE(2,IR).EQ.NTYPE(2,IC)) THEN
         DO I = 1, NTYPE(2,IC)
          EMTBLOCK(I,I) = EMTBLOCK(I,I) + ENONSYM
         ENDDO
        ELSE
         N = 0 ! Column index
         DO I = 1, NORBCOLL
          DO J = 1, NORBCOLU
           N = N + 1
           M = 0 ! Row index
           DO K = 1, NORBROWL
            DO L = 1, NORBROWU
              M = M + 1
              IF (K.EQ.I .AND. L.EQ.J)                               &
                EMTBLOCK(M,N) = EMTBLOCK(M,N) + ENONSYM
            ENDDO
           ENDDO
          ENDDO
         ENDDO

        ENDIF
       ENDIF 

      ENDIF

      IF (LTPOSE) THEN 
        EMTBLOCK=TRANSPOSE(EMTBLOCK)
        IC = ICSAV
        IR = IRSAV
      ENDIF
!cyc  Transfer EMTBLOCK to EMTSYM 
      IF (LTRANSFER) Call transfer_cyc(ICSAV, IRSAV)
  
      RETURN
      END SUBROUTINE MATRIXBLOCK33
