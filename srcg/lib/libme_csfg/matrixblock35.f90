!***********************************************************************
!                                                                      *
      SUBROUTINE MATRIXBLOCK35(ICSAV,IRSAV,NCOEC,INCOR,NCTEC,INC2,     &
                 NMCBP,NCORE,ELSTO)
!                                                                      *
!   This subroutine calls onescalar and computes one electron          *
!   matrix elements when IC and IR are of type 3 and 5                 *
!                                                                      *
!   Written by CHONG-YANG CHEN                               JUNE 2020 *
!   Last modification by C. Y. Chen                          Dec  2022 *
!                                                                      *
!***********************************************************************
!...Translated by Gediminas Gaigalas  May 2021
!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------
      USE vast_kind_param, ONLY: DOUBLE
      USE parameter_def,   ONLY: NNNP
      use symmatrix_mod
      USE buffer_C,   ONLY: NVCOEF, LABEL, COEFF
      USE debug_C,    ONLY: IBUG1
      USE decide_C
      USE def_C
      USE orb_C
!-----------------------------------------------
!   I n t e r f a c e   B l o c k s
!-----------------------------------------------
      IMPLICIT NONE
      EXTERNAL BREID,CORD
!----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
      INTEGER :: ICSAV,IRSAV,NCOEC,INCOR,NCTEC,INC2,NMCBP,NCORE
      REAL(DOUBLE)        :: ELSTO
!-----------------------------------------------
!   L o c a l   P a r a m e t e r s
!-----------------------------------------------
!      REAL(DOUBLE), PARAMETER :: CUTOFF = 1.0D-20
!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
      LOGICAL :: FLAGL,FLAGNONE,FLAGU
      REAL(DOUBLE) :: EMTTMP,ATWINV,ENONSYM,TCOEFF,VCOEFF
      REAL(DOUBLE), DIMENSION(NNNW) :: TSHELL
      INTEGER :: I,IC,IC0,IV,ISWAP,ICPTI,ICPTIJ,ICPTJ,ICW,IFLAG12,IR
      INTEGER :: IR0,IRPTK,IRPTKL,IRPTL,IRW,J,K,L,LABVTMP,M,MTYPE,N
      INTEGER :: NORBCOL,NORBROWL,NORBROWU,ICORBIF(2,2)
!-----------------------------------------------------------------------
! Exchange IC and IR, IC -- TYPE 5, IR --TYPE 3
      IF (LTRANSPOSE) THEN
         IC = IRSAV
         IR = ICSAV
      ! The first COLUMN generated by symmetry-ordered-CSF ICC
      ! The first ROW generated by symmetry-ordered-CSF IRR
      !   IC0 = IRTOT + 1
      !   IR0 = ICTOT + 1
      ELSE
         IC = ICSAV
         IR = IRSAV
      !   IC0 = ICTOT + 1
      !   IR0 = IRTOT + 1
      ENDIF
      IC0 = IC
      IR0 = IR

      ATWINV = 1.D0/EMN
      IBUG1 = 0

!   Set all matrix elements to zero
      !EMTBLOCK = 0.0D0
      TSHELL = 0.D0
      FLAGL = .FALSE.
      FLAGU = .FALSE.
      FLAGNONE = .TRUE. 
! Number of symmetry-ordered orbs for the IC- and IR-th symmetry-ordered-CSFs
      NORBCOL = NTYPE(4,IC) - NTYPE(3,IC) + 1
      NORBROWL = NTYPE(4,IR) - NTYPE(3,IR) + 1
      NORBROWU = NTYPE(6,IR) - NTYPE(5,IR) + 1
      
      IF (NTYPE(3,IC).EQ.NTYPE(3,IR)) FLAGL = .TRUE.
      IF (NTYPE(3,IC).EQ.NTYPE(5,IR)) FLAGU = .TRUE.
      IF (FLAGL .OR. FLAGU) FLAGNONE = .FALSE.

      ! Buiding the FICTIOUTS CSF as needed.
      IF (FLAGL) THEN
        ! K = I (J) 
        CALL FICTIOUS_CSF(5, ICFICT, IC, NTYPE(4,IR), NTYPE(4,IC), 0, 0)
        ICORBIF(1,1) = ICFICT
        ICORBIF(2,1) = NTYPE(4,IR)

        ! K /= I (J)
        IF (NORBCOL.GE.2 .OR. NORBROWL.GE.2) THEN
          IF (NORBCOL.GT.NORBROWL) THEN
            ! No shift needed
            ICORBIF(1,2) = IC
            ICORBIF(2,2) = NTYPE(4,IC)
          ELSE 
           CALL FICTIOUS_CSF(5, ICFICT+1, IC, NTYPE(3,IR), NTYPE(4,IC), 0, 0)
           ICORBIF(1,2) = ICFICT+1
           ICORBIF(2,2) = NTYPE(3,IR)
          ENDIF
        ENDIF
      ENDIF

      IF (FLAGU) THEN
        ! L = I (J) 
        CALL FICTIOUS_CSF(5, ICFICT, IC, NTYPE(6,IR), NTYPE(4,IC), 0, 0)
        ICORBIF(1,1) = ICFICT
        ICORBIF(2,1) = NTYPE(6,IR)

        ! L /= I (J)
        IF (NORBCOL.GE.2 .OR. NORBROWU.GE.2) THEN
          IF (NORBCOL.GT.NORBROWU) THEN
            ! No shift needed
            ICORBIF(1,2) = IC
            ICORBIF(2,2) = NTYPE(4,IC)
          ELSE 
           CALL FICTIOUS_CSF(5, ICFICT+1, IC, NTYPE(5,IR), NTYPE(4,IC), 0, 0)
           ICORBIF(1,2) = ICFICT+1
           ICORBIF(2,2) = NTYPE(5,IR)
          ENDIF
        ENDIF
      ENDIF
! There is no onebody contribution for type 3 - 5 

!   ENONSYM that does not include the symmetry-ordered orbital. 
      NVCOEF = 0
      ENONSYM = 0.D0
      COEFF = 0.0D0 

      IRW = IR0
      ICW = IC0
      IF (FLAGL .OR. FLAGU) ICW = ICORBIF(1,1)

      CALL RKCO_GG (ICW, IRW, CORD, INCOR, 1)
      IF (NVCOEF .GT. 0) LTRANSFER = .TRUE.
      IF (NVCOEF.GT.0) THEN
       DO IV = 1, NVCOEF
        VCOEFF = COEFF(IV)
        IF (DABS (VCOEFF) .GT. CUTOFF) THEN
          NCTEC = NCTEC + NTYPE(2,IC) 

! Determine the position of the symmetry-ordered orbitals
          LABV=LABEL(1:6, IV)
          CALL ANALABV(IC, IR, IV)
          IF (NSYMCR .EQ. 0) THEN 
            WRITE(*,'(a3, i7, 2x, i7, 2x, a5, 5i3)')                 &
                 'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
            STOP 'Warning!!! NSYMCR ERROR ***0***'
! The following two lines needed in other cases.
           ! CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
           ! ENONSYM = ENONSYM + EMTTMP

          ELSEIF (NSYMCR .EQ. 1) THEN 
           WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')              &
                'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
           STOP 'Warning!!! NSYMCR ERROR ***1***'

! Loop for symmetry-ordered-orbitals
          ELSEIF (NSYMCR .EQ. 2) THEN 
           ![core] 10p 11p -- (core) 10p- 11p. 
           N = 0  ! Column index
           DO I = 1, NORBCOL  
             N = N + 1
             M = 0  ! Row index 
             DO K = 1, NORBROWL
              DO L = 1, NORBROWU
               ! FULL MATRIX NEEDED, NOT TRIANGLE
               M = M + 1 
               IF (FLAGL) THEN
                 IF (K.EQ.I) THEN 
                  LABV(IPSYM(1)) = NTYPE(3, IC) + I - 1
                  LABV(IPSYM(2)) = NTYPE(5, IR) + L - 1
                  CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
                  EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                 ENDIF
               ELSEIF (FLAGU) THEN
                 IF (L.EQ.I) THEN
                   LABV(IPSYM(1)) = NTYPE(3, IC) + I - 1
                   LABV(IPSYM(2)) = NTYPE(3, IR) + K - 1
                   CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
                   EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                 ENDIF
               ENDIF

              ENDDO
             ENDDO
           ENDDO

          ELSEIF (NSYMCR .EQ. 3) THEN
           WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')              &
                'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
           STOP 'Warning!!! NSYMCR ERROR ***3***'

          ELSEIF (NSYMCR .EQ. 4) THEN 
           N = 0 
           DO I = 1, NORBCOL
            LABV(1) =  NTYPE(3,IC) + I - 1
            LABV(2) =  NTYPE(3,IC) + I - 1
            N = N + 1
            M = 0
            DO K = 1, NORBROWL
             DO L = 1, NORBROWU
              M = M + 1
              ! Full matrix needed
              LABV(3) = NTYPE(3,IR) + K - 1
              LABV(4) = NTYPE(5,IR) + L - 1
              IF (LABEL(3,IV).GT.LABEL(4,IV)) THEN 
                 LABVTMP = LABV(3)
                 LABV(3) = LABV(4)
                 LABV(4) = LABVTMP
              ENDIF
              CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
              EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
             ENDDO
            ENDDO
           ENDDO
          ENDIF 
        ENDIF
       ENDDO
      ENDIF

! No common parts for the diagonal matrixelement in case of type 3 - 5 
!
      IBUG1 = 0
!   Accumulate the contribution from the two-electron
!   transverse interaction operator
      IF (LTRANS .AND. (INC2.EQ.1)) THEN 
       ENONSYM = 0.0d0
       DO MTYPE = 1, 2
        NVCOEF = 0
        COEFF = 0
        IF (MTYPE.EQ.1) THEN
         IF (FLAGNONE) CYCLE
         ! FLAGL: 
         ! < (Core A) 10s10p | h_br | (Core B) 9s2 >
         ! < K L | h_br | I J >: K != I (J)
         ! .OR. FLAGU: 
         ! < (Core A) 10s10p | h_br | (Core B) 9p2 >
         ! < K L | h_br | I J >: L != I (J)
         IF (FLAGL.AND.NORBROWL.LT.2.AND.NORBCOL.LT.2) CYCLE ! At least 2 orbitals in the same sym.  
         IF (FLAGU.AND.NORBROWU.LT.2.AND.NORBCOL.LT.2) CYCLE ! At least 2 orbitals in the same sym.  
         ! < (Core A) 4s4p (IR0) | h_br | (Core B) 4s2 (IC0)>
         ! < (Core A) 4s4p (IR0) | h_br | (Core B) 4p2 (IC0)>
         IRW = IR0
         ICW = 2
         CALL RKCO_GG (ICORBIF(1,ICW), IRW, BREID, 1, 2)

        ELSEIF (MTYPE.EQ.2) THEN
         ! < (Core) 10s 10p | h_br | (Core) 10s2 >
         ! < (Core) 10s 10p | h_br | (Core) 10p2 >
         ! < (Core) 10s 10p | h_br | (Core) 10d2 >
         ! FLEXIBLE ORBITAL SET:
         ! < (Core)  4s  4p | h_br | (Core)  4s2 >
         ! < (Core)  4s  4p | h_br | (Core)  4p2 >
         ! < (Core)  4s  4p | h_br | (Core)  4d2 >
         IF (FLAGNONE) THEN 
           ICW = IC0
           IRW = IR0
           CALL RKCO_GG (ICW, IRW, BREID, 1, 2)
         ELSE
           ICW = 1
           IRW = IR0
           CALL RKCO_GG (ICORBIF(1,ICW), IRW, BREID, 1, 2)
         ENDIF 
        ENDIF
        IF (NVCOEF .GT. 0) LTRANSFER = .TRUE.
        DO 10 IV = 1, NVCOEF
          VCOEFF = COEFF(IV)
          IF (DABS (VCOEFF) .GT. CUTOFF) THEN
            NMCBP = NMCBP + NTYPE(2,IC)
! Determine the position of the symmetry-ordered orbitals
            LABV = LABEL(1:6,IV)
            CALL ANALABV(IC, IR, IV)

            IF (NSYMCR .EQ. 0) THEN
! No common part for 3 - 5 matrixelement
             WRITE(*,*)'IC,IR,IV,MTYPE=',IC,IR,IV,MTYPE
             STOP 'Unexpected NSYMCR .EQ. 0 in matrixblock35.f ...'

! Matrixelement between Type 3 - 5, Loop for symmetry-ordered-orbitals
            ELSEIF (NSYMCR .EQ. 1) THEN
             WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')            &
                  'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
             STOP 'Warning!!! NSYMCR ERROR ***1***'
             
            ELSEIF (NSYMCR .EQ. 2) THEN
             IF (MTYPE.EQ.1 .OR. FLAGNONE) THEN
              WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')           &
                  'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
              STOP 'Unexpected MTYPE.EQ.1 .OR. FLAGNONE B35.f ...'
             ENDIF

! Determine the positions for symmetry-ordered-orb of IR (K, L) / IC (I, J) 
             IRPTKL = 0
             ICPTIJ = 0
             IFLAG12 = 0
             IF (MTYPE.EQ.2) THEN
              IF(FLAGL.AND.LABEL(IPSym(1),IV).NE.NTYPE(6,IRW)) IFLAG12=1
              IF(FLAGU.AND.LABEL(IPSym(1),IV).NE.NTYPE(4,IRW)) IFLAG12=1
             ENDIF
             IF (IFLAG12.EQ.0) THEN
               IRPTKL = IPSym(1)
               ICPTIJ = IPSym(2)
             ELSE
               IRPTKL = IPSym(2)
               ICPTIJ = IPSym(1)
             ENDIF

             N = 0  ! Column index
             DO I = 1, NORBCOL
                J = I
                N = I
                M = 0
                DO K = 1, NORBROWL
                 DO L =  1, NORBROWU
                  M = M + 1  ! Row index
                  ! Full matrix needed
                  ! IF (K .GT. I) CYCLE ! IR INNER ALWAYS <= IC INNER ORB
                  ! IF (K .EQ. I .AND. L.GT.J) CYCLE 
                  IF (FLAGL .AND. K.EQ.I) THEN
                    ! < K L | h_br | I J >: K = I, FLAGL
                    LABV(IRPTKL) = NTYPE(5, IR) + L - 1
                    LABV(ICPTIJ) = NTYPE(3, IC) + J - 1
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                  ELSEIF (FLAGU .AND. L.EQ.I) THEN 
                    ! < K L | h_br | I J >: L = I, FLAGU
                    LABV(IRPTKL) = NTYPE(3, IR) + K - 1
                    LABV(ICPTIJ) = NTYPE(3, IC) + J - 1
                    CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                    EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                  ENDIF 
                 ENDDO
                ENDDO
             ENDDO

            ELSEIF (NSYMCR .EQ. 3) THEN
             WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')            &
                  'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
             STOP 'Warning!!! NSYMCR ERROR ***3***'

            ELSEIF (NSYMCR .EQ. 4) THEN
! Determine the positions of the symmetry-ordered orbitals 
             IRPTK = 0
             IRPTL = 0
             ICPTI = 0
             ICPTJ = 0 

             IF (MTYPE.EQ.1) THEN
              DO I = 1, 4
               IF (LABEL(I,IV).EQ.NTYPE(4,IRW)) IRPTK = I
               IF (LABEL(I,IV).EQ.NTYPE(6,IRW)) IRPTL = I
               IF (LABEL(I,IV).EQ.ICORBIF(2,ICW)) THEN
                 IF (ICPTI.EQ.0) THEN
                   ICPTI = I
                 ELSE
                   ICPTJ = I
                 ENDIF
               ENDIF
              ENDDO
             ENDIF

             IF (MTYPE.EQ.2) THEN
               IF (FLAGL) THEN
                 DO I = 1, 4 
                  IF (LABEL(I,IV).EQ.NTYPE(6,IRW)) IRPTL = I
                  IF (LABEL(I,IV).EQ.NTYPE(4,IRW)) THEN
                    IF (IRPTK.EQ.0) THEN
                      IRPTK = I
                    ELSEIF (ICPTI.EQ.0) THEN
                      ICPTI = I
                    ELSE
                      ICPTJ = I
                    ENDIF  
                  ENDIF
                 ENDDO 
               ELSEIF (FLAGU) THEN
                 DO I = 1, 4
                  IF (LABEL(I,IV).EQ.NTYPE(4,IRW)) IRPTK = I
                  IF (LABEL(I,IV).EQ.NTYPE(6,IRW)) THEN
                    IF (IRPTL.EQ.0) THEN
                      IRPTL = I
                    ELSEIF (ICPTI.EQ.0) THEN
                      ICPTI = I
                    ELSE
                      ICPTJ = I
                    ENDIF
                  ENDIF
                 ENDDO
               ELSEIF (FLAGNONE) THEN
                DO I = 1, 4 
                 IF (LABEL(I,IV).EQ.NTYPE(4,IRW)) IRPTK = I
                 IF (LABEL(I,IV).EQ.NTYPE(6,IRW)) IRPTL = I
                 IF (LABEL(I,IV).EQ.NTYPE(4,ICW)) THEN
                   IF (ICPTI.EQ.0) THEN
                     ICPTI = I
                   ELSE
                     ICPTJ = I 
                   ENDIF
                 ENDIF 
                ENDDO 
               ENDIF 
             ENDIF
! Check
      IF (IRPTK*IRPTL*ICPTI*ICPTJ.EQ.0) THEN
        WRITE(*,*)'IC,IR,IV,IRPTK*IRPTL*ICPTI*ICPTJ= ',              &
        IC,IR,IV,IRPTK,IRPTL,ICPTI,ICPTJ
        STOP 'Unexpected IRPTK*IRPTL*ICPTI*ICPTJ.EQ.0...'
      ENDIF
 
! Loop over the symmetry-ordered orbitals
             N = 0  ! Column index
             DO I = 1, NORBCOL
                J = I 
                N = I
                M = 0
                DO K = 1, NORBROWL
                 DO L = 1, NORBROWU
                  M = M + 1  ! Row index

                  IF (MTYPE.EQ.1.AND.FLAGL.AND.K.EQ.I) CYCLE
                  IF (MTYPE.EQ.1.AND.FLAGU.AND.L.EQ.I) CYCLE
                  IF (MTYPE.EQ.2.AND.FLAGL.AND.K.NE.I) CYCLE
                  IF (MTYPE.EQ.2.AND.FLAGU.AND.L.NE.I) CYCLE
                  LABV(IRPTK) = NTYPE(3,IR) + K - 1
                  LABV(IRPTL) = NTYPE(5,IR) + L - 1
                  LABV(ICPTI) = NTYPE(3,IC) + I - 1
                  LABV(ICPTJ) = NTYPE(3,IC) + J - 1
                  CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                  EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                 ENDDO
                ENDDO
             ENDDO
            ENDIF
          ENDIF
   10   CONTINUE
       ENDDO
      ENDIF

!cyc  Transfer EMTBLOCK to EMTSYM 
      IF (LTRANSPOSE) EMTBLOCK=TRANSPOSE(EMTBLOCK)
      IF (LTRANSFER) call transfer_cyc(ICSAV, IRSAV)

      RETURN
      END SUBROUTINE MATRIXBLOCK35
