!***********************************************************************
!                                                                      *
      SUBROUTINE MATRIXBLOCK55(IC,IR,NCOEC,INCOR,NCTEC,INC2,NMCBP,     &
                 NCORE,ELSTO)
!                                                                      *
!   This subroutine calls onescalar and computes one electron          *
!   matrix elements when IC !=  IR, and are both of type 5             * 
!                                                                      *
!   Written by CHONG-YANG CHEN                               JUNE 2020 *
!   Last modification by C. Y. Chen                          Dec  2022 *
!                                                                      *
!***********************************************************************
!...Translated by Gediminas Gaigalas  May 2021
!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------
      USE vast_kind_param, ONLY: DOUBLE
      USE parameter_def,   ONLY: NNNP
      USE symmatrix_mod
      USE buffer_C,   ONLY: NVCOEF, LABEL, COEFF
      USE debug_C,    ONLY: IBUG1
      USE decide_C
      USE def_C
      USE orb_C
!-----------------------------------------------
!   I n t e r f a c e   B l o c k s
!-----------------------------------------------
      IMPLICIT NONE
      EXTERNAL BREID,CORD
!----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
      INTEGER :: IC,IR,NCOEC,INCOR,NCTEC,INC2,NMCBP,NCORE
      REAL(DOUBLE)        :: ELSTO
!-----------------------------------------------
!   L o c a l   P a r a m e t e r s
!-----------------------------------------------
!
!   Matrix elements smaller than CUTOFF are not accumulated
!
!      REAL(DOUBLE), PARAMETER :: CUTOFF = 1.0D-20
!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
      LOGICAL :: FLAGSAME
      REAL(DOUBLE) :: EMTTMP,ATWINV,ENONSYM,TCOEFF,VCOEFF
      REAL(DOUBLE), DIMENSION(NNNW) :: TSHELL
      INTEGER :: IA,IB,IV,ISWAP,I,IC0,ICPTI,ICPTJ,ICW,IR0,IRPTK,IRPTL
      INTEGER :: IRW,J,K,L,M,MTYPE,N,NORBCOL,NORBROW,IRORB4,IR1
!-----------------------------------------------------------------------
      ! The first COLUMN generated by symmetry-ordered-CSF ICC
      ! The first ROW generated by symmetry-ordered-CSF IRR
      !IC0 = ICTOT + 1
      !IR0 = IRTOT + 1
      IC0 = IC
      IR0 = IR
      ATWINV = 1.D0/EMN
      IBUG1 = 0

!   Set all matrix elements to zero
      !EMTBLOCK = 0.0D0
      TSHELL = 0.D0
      FLAGSAME = .FALSE.
! Number of symmetry-ordered orbs for the IC- and IR-th symmetry-ordered-CSFs
! For type 4, NTYPE(4,IC) = NTYPE(6,IC) - 1
      NORBCOL = NTYPE(4,IC) - NTYPE(3,IC) + 1
      NORBROW = NTYPE(4,IR) - NTYPE(3,IR) + 1
      
      ! THERE ARE ONEBODY CONTRIBUTIONS TO THE MATRIXELEMENTS OF TYPE 
      ! 5 -  5 FOR ONLY THOSE WITH THE SAME symmetry-ordered-orbs, BUT DIFFERING
      ! FROM EACH OTHER BY ONLY ONE CORE-ORBITAL, SUCH AS [CORE A] 11S2
      ! -- [CORE B] 11S2
      IF (NTYPE(3,IC) .NE. NTYPE(3,IR)) GOTO 101
      FLAGSAME = .TRUE.

      ! Buiding the FICTIOUTS CSF as needed.
      IF (NORBROW.NE.NORBCOL) THEN
        CALL FICTIOUS_CSF(5, IRFICT, IR, NTYPE(4,IC),     &
                                         NTYPE(4,IR), 0, 0)
        IR0 = IRFICT  ! K  = I
        IR1 = IR      ! K /= I
        IRORB4 = NTYPE(4,IR) 
      ELSEIF (NORBROW.GT.1) THEN
        CALL FICTIOUS_CSF(5, IRFICT, IR, NTYPE(3,IR),     &
                                         NTYPE(4,IR), 0, 0)
        IR0 = IR      ! K  = I
        IR1 = IRFICT  ! K /= I
        IRORB4 = NTYPE(3,IR) 
      ENDIF
      
!   Call onescalar 
      ! 4s2 -- 4s2
      CALL ONESCALAR(IC0,IR0,IA,IB,TSHELL)
!   
!   Accumulate the contribution from the one-body operators:
!   kinetic energy, electron-nucleus interaction; update the
!   angular integral counter
!
!   Type 5 - 5
!
! SEMI-DIAGONAL: 
      ENONSYM = 0.0D0
      IF (IA .NE. 0) THEN
        LTRANSFER = .TRUE. 
!   Ensure that the indices are in `canonical' order
        IF (IA .GT. IB) THEN
          ISWAP = IB
          IB = IA
          IA = ISWAP
          !For such CSF-pair, the one-body contribution arises from
          !the core-orbitals. 
          IF (IB.GT.NORBGEN) then
            WRITE(*,*)'IC,IR,IA,IB,TSHELL=',IC,IR,IA,IB,TSHELL(1)
            STOP 'Error, IA.gt.IB and IB.gt.NORBGEN in matrixblock12.'
          ENDIF
        ENDIF
        TCOEFF = DBLE(TSHELL(1))
        IF (DABS(TCOEFF) .GT. CUTOFF) THEN
          NCOEC = NCOEC + NTYPE(2,IC) 
          !No symmetry-ordered-Orb contributions, no needing to change IB
          !IB = I + NTYPE(3,IC) - 1

          CALL onebody_DC_MS_VP(IA,IB,ATWINV,TCOEFF,EMTTMP)
          DO I =1, MIN(NTYPE(2,IC),NTYPE(2,IR))
            EMTBLOCK(I,I) = EMTTMP
          END DO
        ENDIF
      ENDIF
! There is no one-body contribution to off-diagonal elements.

101   CONTINUE

!   ENONSYM that does not include the symmetry-ordered orbital. 
      NVCOEF = 0
      ENONSYM = 0.D0
      ICW = IC0
      IRW = IR0
      CALL RKCO_GG (ICW, IRW, CORD, INCOR, 1)
      IF (NVCOEF .GT. 0) LTRANSFER = .TRUE.
      DO IV = 1, NVCOEF
        VCOEFF = COEFF(IV)
        IF (DABS (VCOEFF) .GT. CUTOFF) THEN
          NCTEC = NCTEC + NTYPE(2,IC) 

! Determine the position of the symmetry-ordered orbitals
          LABV=LABEL(1:6, IV)
          CALL ANALABV(IC, IR, IV)

          IF (NSYMCR .EQ. 0) THEN 
            CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
            ENONSYM = ENONSYM + EMTTMP

          ELSEIF (NSYMCR .EQ. 1 ) THEN 
           WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')              &
                'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
           STOP 'Warning!!! NSYMCR ERROR ***1***'

          ELSEIF (NSYMCR .EQ. 2 ) THEN
           DO I = 1, MIN(NORBCOL,NORBROW)
             !DIAGONAL MATRIXELEMENT IN EMTBLOCK, 1s2 11s2 -- 1s2s 11s2
             LABV(IPSYM(1)) = NTYPE(3, IC) + I - 1
             LABV(IPSYM(2)) = NTYPE(3, IR) + I - 1
             CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
             EMTBLOCK(I,I) = EMTBLOCK(I,I) + EMTTMP
           ENDDO

          ELSEIF (NSYMCR .EQ. 3 ) THEN
           WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')              &
                'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
           STOP 'Warning!!! NSYMCR ERROR ***3***'

          ELSEIF (NSYMCR .EQ. 4 ) THEN 
           DO N = 1, NORBCOL
            LABV(1) =  NTYPE(3,IC) + N - 1
            LABV(2) =  NTYPE(3,IC) + N - 1
            DO M = 1, NORBROW ! Full matrix needed
             LABV(3) =  NTYPE(3,IR) + M - 1
             LABV(4) =  NTYPE(3,IR) + M - 1
             CALL twobody_DC_SMS(ATWINV, VCOEFF, EMTTMP)
             EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
            ENDDO
           ENDDO

          ENDIF 
        ENDIF
      ENDDO
! Add the common parts for the diagonal matrixelement 
      IF (DABS(ENONSYM) .GT. CUTOFF) THEN
        DO I = 1, MIN(NTYPE(2, IC),NTYPE(2, IR))
           EMTBLOCK(I,I) = EMTBLOCK(I,I) + ENONSYM
        ENDDO
      ENDIF

      IBUG1 = 0
!   Accumulate the contribution from the two-electron
!   transverse interaction operator
      IF (LTRANS .AND. (INC2.EQ.1)) THEN !Kai:What do these arugments mean?
       ENONSYM = 0.0d0
       DO MTYPE = 1, 2
        NVCOEF = 0
        COEFF = 0
        IF (MTYPE.EQ.1) THEN
         IF (.NOT.FLAGSAME) CYCLE
         ! < (Core A) 9s2  | h_br | (Core B) 10s2 >
         ! < K L | h_br | I J >: (K = L) != (I = J)
         IF (NORBROW.LT.2 .AND. NORBCOL.LT.2) CYCLE ! At least 2 orbitals in the same sym.  
         ! IR 4s2 , IW 5s2; or IR 5s2, IW 4s2
         ICW = IC0
         IRW = IR1
         CALL RKCO_GG (ICW, IRW, BREID, 1, 2)

        ELSEIF (MTYPE.EQ.2) THEN
         ! FLAGSAME: K = L = I = J  
         ! < (Core A)  10s2 | h_br | (Core) 10s2 >
         ! .NOT. FLAGSAME: 
         ! < (Core)    10s2 | h_br | (Core) 10p2 >
         ! 4s2 -- 4s2
         ICW = IC0
         IRW = IR0
         CALL RKCO_GG (ICW, IRW, BREID, 1, 2)
        ENDIF
        IF (NVCOEF .GT. 0) LTRANSFER = .TRUE.
        DO 10 IV = 1, NVCOEF
          VCOEFF = COEFF(IV)
          IF (DABS (VCOEFF) .GT. CUTOFF) THEN
            NMCBP = NMCBP + NTYPE(2,IC)
! Determine the position of the symmetry-ordered orbitals
            LABV = LABEL(1:6,IV)
            CALL ANALABV(IC, IR, IV)

            IF (NSYMCR .EQ. 0) THEN
! No common part for 4 - 5 matrixelement
             IF (MTYPE.NE.2 .OR. (.NOT. FLAGSAME)) THEN
               WRITE(*,*)'IC,IR,IV,MTYPE=',IC,IR,IV,MTYPE
               STOP 'Unexpected NSYMCR .EQ. 0 in matrixblock55.f ...'
             ENDIF
             CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
             ENONSYM = ENONSYM + EMTTMP

            ELSEIF (NSYMCR .EQ. 1) THEN
             WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')            &
                  'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
             STOP 'Warning!!! NSYMCR ERROR ***1***'
             
            ELSEIF (NSYMCR .EQ. 2) THEN
             IF (MTYPE.NE.2 .OR. (.NOT.FLAGSAME)) THEN
              WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')           &
                  'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
              STOP 'Unexpected MTYPE.EQ.1 .OR. (.NOT.FLAGSAME) in B55.f'
             ENDIF

             N = 0  ! Column index
             DO I = 1, NORBCOL
                J = I
                N = I
                M = 0
                DO K = 1, NORBROW
                  L = K
                  M = K  ! Row index
                  IF (K.NE.I) CYCLE
                  LABV(IPSYM(1)) = NTYPE(3, IR) + K - 1
                  LABV(IPSYM(2)) = NTYPE(3, IC) + I - 1
                  CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                  EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                ENDDO
             ENDDO

            ELSEIF (NSYMCR .EQ. 3) THEN
             WRITE(*,'(a3, i7, 2x, a3, i7, 2x, a5, 5i3)')            &
                  'IC=', IC, 'IR=', IR, 'LABV=', LABV(1:5)
             STOP 'Warning!!! NSYMCR ERROR ***3***'

            ELSEIF (NSYMCR .EQ. 4) THEN
! Determine the positions of the symmetry-ordered orbitals 
             IRPTK = 0
             IRPTL = 0
             ICPTI = 0
             ICPTJ = 0
             IF (MTYPE.EQ.1) THEN
         ! < (Core A) 9s2 | h_br | (Core B) 10s2 >
              DO I = 1, 4
               !IF (LABEL(I,IV).EQ.NTYPE(4,IRW)) THEN
               IF (LABEL(I,IV).EQ.IRORB4) THEN
                 IF (IRPTK.EQ.0) THEN
                   IRPTK = I
                 ELSE
                   IRPTL = I
                 ENDIF
               ENDIF
               IF (LABEL(I,IV).EQ.NTYPE(4,ICW)) THEN
                 IF (ICPTI.EQ.0) THEN
                   ICPTI = I
                 ELSE
                   ICPTJ = I
                 ENDIF
               ENDIF
              ENDDO

             ELSEIF (MTYPE.EQ.2) THEN
         ! < (Core)  10s2 | h_br | (Core) 10s2 >
              IF (FLAGSAME) THEN
                ! K = L = I = J
                IRPTK = 1
                IRPTL = 2
                ICPTI = 3
                ICPTJ = 4
              ELSE
               DO I = 1, 4 
                 IF (LABEL(I,IV).EQ.NTYPE(4,IRW)) THEN
                   IF (IRPTK.EQ.0) THEN
                     IRPTK = I
                   ELSE
                     IRPTL = I
                   ENDIF
                 ENDIF
                 IF (LABEL(I,IV).EQ.NTYPE(4,ICW)) THEN
                   IF (ICPTI.EQ.0) THEN
                     ICPTI = I
                   ELSE
                     ICPTJ = I
                   ENDIF
                 ENDIF
               ENDDO
              ENDIF 
             ENDIF 
! Check
      IF (IRPTK*IRPTL*ICPTI*ICPTJ.EQ.0) THEN
        WRITE(*,*)'IC,IR,IV,IRPTK*IRPTL*ICPTI*ICPTJ= ',              &
        IC,IR,IV,IRPTK,IRPTL,ICPTI,ICPTJ
        STOP 'Unexpected IRPTK*IRPTL*ICPTI*ICPTJ.EQ.0... in B55.f ...'
      ENDIF       
! Loop over the symmetry-ordered orbitals
             N = 0  ! Column index
             DO I = 1, NORBCOL
                J = I 
                N = I
                DO K = 1, NORBROW
                  L = K 
                  M = K  ! Row index

                  IF (MTYPE.EQ.1.AND.K.EQ.I) CYCLE
                  IF (MTYPE.EQ.2.AND.FLAGSAME.AND.K.NE.I) CYCLE
                  LABV(IRPTK) = NTYPE(3,IR) + K - 1
                  LABV(IRPTL) = NTYPE(3,IR) + L - 1
                  LABV(ICPTI) = NTYPE(3,IC) + I - 1
                  LABV(ICPTJ) = NTYPE(3,IC) + J - 1
                  CALL breit_d(IC,IR,IV,VCOEFF,NCORE,ELSTO,EMTTMP)
                  EMTBLOCK(M,N) = EMTBLOCK(M,N) + EMTTMP
                ENDDO
             ENDDO
            ENDIF
          ENDIF
   10   CONTINUE
       ENDDO

! Add the common parts for the diagonal matrixelement 
       IF (DABS(ENONSYM) .GT. CUTOFF) THEN
        IF (NTYPE(3,IC).NE.NTYPE(3,IR)) THEN
          WRITE(*,*)'IC,IR,ENONSYM=', IC,IR,ENONSYM
          STOP 'Unexpected NTYPE(3,IC).NE.NTYPE(3,IR) in B55.f ...'
        ENDIF
        DO I = 1, MIN(NTYPE(2, IC), NTYPE(2, IR))
           EMTBLOCK(I,I) = EMTBLOCK(I,I) + ENONSYM
        ENDDO
       ENDIF
      ENDIF

!cyc  Transfer EMTBLOCK to EMTSYM 
      IF (LTRANSFER) call transfer_cyc(IC, IR)

      RETURN
      END SUBROUTINE MATRIXBLOCK55
